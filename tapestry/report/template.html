<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Tapestry: quality assessment for small genome assemblies">
  <meta name="author" content="Tapestry">

  <title>Tapestry Report</title>
  
  <style type="text/css">
      {{ include_file('static/litera.epic.css') }}
      {{ include_file('static/bootstrap-table.min.css') }}
      {{ include_file('static/bootstrap-table-reorder-rows.min.css') }}
  </style>
  <style>
      html {
          font-size: 14px;
      }
      #assembly_section { 
          display: flex; 
      }
      .xaxis { font-size: 14px; }
      .yaxis { font-size: 14px; }
      .xaxislabel { font-size: 16px; font-weight: bold; }
      .yaxislabel { font-size: 16px; font-weight: bold; }
  }
  </style>
</head>

<body>
  <div class="mainpage">
    <h1 id="page_title">Tapestry Report</h1>

    <noscript>
      <div class="alert alert-danger">
        <h4>JavaScript Disabled</h4>
        <p>
          Tapestry uses JavaScript, but it looks like
          you have JavaScript disabled in your web browser.
          Please enable JavaScript to view the full report.
        </p>
      </div>
    </noscript>

    <div>
      <table id="assembly_table" data-sort-name="cluster" data-sort-order="asc">
        <thead>
          <tr>
            <th data-field="assembly" data-sortable="true">Contig set</th>
            <th data-field="contigs" data-sortable="true">Contig number</th>
            <th data-field="length" data-sortable="true">Length (bp)</th>
            <th data-field="n50_number" data-sortable="true">N50 number</th>
            <th data-field="n50_length" data-sortable="true">N50 length</th>
          </tr>
        </thead>
      </table>
    </div>

    <div id="assembly_section">
        <div id="assembly_plot"></div>
        <table id="contig_table">
          <thead>
            <tr>
              <th data-radio="true"></th>
              <th data-field="name" data-sortable="true" data-align='left'>Contig</th>
              <th data-field="length" data-sortable="true" data-align='right' data-formatter="length_formatter">Length</th>
              <th data-field="gc" data-sortable="true" data-align='right'>GC %</th>
              <th data-field="median_read_depth" data-sortable="true" data-align='right'>Read Depth</th>
              <th data-field="cluster" data-sortable="true" data-editable="true" data-align='right'>Cluster</th>
              <th data-field="included" data-sortable="true" data-formatter="include_checkbox" data-align='center'>Keep</th>
              <th data-field="notes" data-sortable="true" data-editable="true">Notes</th>
            </tr>
          </thead>
        </table>
    </div>

    <div id="read_alignment_plot"></div>

  </div>
<script type="text/javascript">
{{ include_file('static/jquery-3.3.1.min.js') }}
{{ include_file('static/popper.min.js') }}
{{ include_file('static/bootstrap.min.js') }}
{{ include_file('static/bootstrap-editable.min.js') }}
{{ include_file('static/FileSaver.min.js') }}
{{ include_file('static/tableExport.min.js') }}
{{ include_file('static/jquery.tablednd.min.js') }}
{{ include_file('static/fontawesome.all.min.js') }}
{{ include_file('static/bootstrap-table.min.js') }}
{{ include_file('static/bootstrap-table-export.min.js') }}
{{ include_file('static/bootstrap-table-editable.min.js') }}
{{ include_file('static/bootstrap-table-reorder-rows.min.js') }}

// Use hacked version for Bootstrap 4 from https://github.com/wenzhixin/bootstrap-table/issues/4258
{{ include_file('static/bootstrap-table-multiple-sort.js') }}

{{ include_file('static/d3.min.js') }}

var windowsize = {{ windowsize }};
var median_depth = {{ median_depth }};
var contigs = {{ contigs }};
var read_alignments = {{ read_alignments }};
var contig_alignments = {{ contig_alignments }};
var contig_coverage = {{ contig_coverage }};
var ploidys = {{ ploidys }};

var current_aligned_contig = '';

var contig_names = {};
var contig_short_long = {};
var contig_id_short = {};
var contig_short_id = {};
var contig_lengths = {};
contigs.forEach(function(contig) {
    contig.included = 1;
    contig.notes = '';
    contig_names[contig.longname] = contig.name;
    contig_short_long[contig.name] = contig.longname;
    contig_id_short[contig.id] = contig.name;
    contig_short_id[contig.name] = contig.id;
    contig_lengths[contig.id] = contig.length;
})

var contig_links = {};
for (var contig_name_long in contig_alignments) {
    contig_name_short = contig_names[contig_name_long];
    contig_links[contig_name_short] = [];
    contig_matches = [...new Set(contig_alignments[contig_name_long].map(d => contig_id_short[d[2]]))]
    contig_matches.forEach(function(contig_match) {
        if (contig_name_short != contig_match) {
            contig_links[contig_name_short].push({source: {"x":-1, "y": contig_name_short}, target: {"x":0, "y": contig_match}});
        }
    })
}

var contig_coverage_prop = {};
for (var contig_id_1 in contig_coverage) {
    contig_coverage_prop[contig_id_1] = {};
    for (var contig_id_2 in contig_coverage[contig_id_1]) {
        contig_coverage_prop[contig_id_1][contig_id_2] = contig_coverage[contig_id_1][contig_id_2]/contig_lengths[contig_id_1];
    }
}

function get_assembly_length(contigs) {
    return contigs.reduce((a,b) => ({length: a.length + b.length}), {length: 0}).length;
}

function get_n50_stats(contiglist, assembly_length) {
    var n50_length = 0
    var n50_number = 0
    var n50_cumul_length = 0
    
    contiglist.slice(0).sort((a,b) => b.length - a.length).forEach(function(c) {
        if (n50_cumul_length >= assembly_length / 2) { return; }
        n50_number += 1;
        n50_length = c.length;
        n50_cumul_length += c.length;
    })
    
    return [n50_number, n50_length];
}

function length_formatter(value) {
    return value.toLocaleString();
}

function calculate_assembly_stats(contigs, label) {
    var assembly_length = get_assembly_length(contigs);
    var [n50_number, n50_length] = get_n50_stats(contigs, assembly_length);

    return {assembly: label,
            contigs: contigs.length,
            length: assembly_length.toLocaleString(),
            n50_number: n50_number,
            n50_length: n50_length.toLocaleString()};
}

function calculate_stats(contigs) {
    return [
        calculate_assembly_stats(contigs, "All contigs"),
        calculate_assembly_stats(contigs.slice(0).filter(c => c.included), "Selected contigs"),
        calculate_assembly_stats(contigs.slice(0).filter(c => !c.included), "Rejected contigs")
    ]
}

ploidy_depths = [ {name:'haploid',    depth: median_depth * 0.5}, 
                  {name:'diploid',    depth: median_depth      }, 
                  {name:'triploid',   depth: median_depth * 1.5}, 
                  {name:'tetraploid', depth: median_depth * 2  },
                  {name:'repeat',     depth: median_depth * 2.5} ];

function check_max(max_val, list, i) {
    var list_max = d3.max(list, function(d) {return d[i]});
    if (max_val < list_max) {
        max_val = list_max;
    }
    return max_val;
}

function check_min(min_val, list, i) {
    var list_min = d3.min(list, function(d) {return d[i]});
    if (min_val > list_min) {
        min_val = list_min;
    }
    return min_val;
}

function mq_opacity(mq) { return 0.1 + 0.9*mq/60 }

function clip_colour(type) {
    if (type === 'C') { // Connection
        return 'purple'
    } else if (type === 'L') { // Loose
        return 'orange'
    } else if (type === 'S') { // Self (within-contig)
        return 'pink'
    } else {
        return 'black'
    }
}

function contig_text_hover(x, y, contig_id, anchor) {
    reads_svg.append("text")
        .attr("class", "alignment text")
        .attr("x", dim.xscale(x))
        .attr("y", reads_dim.yscale(y))
        .attr("text-anchor", anchor)
        .attr("alignment-baseline", "middle")
        .attr("fill", "black")
        .attr("font-size", "10px")
        .text(contig_id == -1 ? '-' : contig_id_short[contig_id]);
}

function contig_text_unhover() {
    reads_svg.selectAll("text.alignment.text").remove()
}

function plot_read_alignments(alignments, dim, assembly_dim, reads_dim, svg, contig) {

    // contig_read_alignments:
    //  0 read start including left clip
    //  1 contig alignment start
    //  2 contig alignment end
    //  3 read end including right clip
    //  4 mapping quality
    //  5 y position on plot

    svg.selectAll("text.xaxislabel").remove()
    
    svg.append("text")
       .attr("class", "xaxislabel")
       .attr("transform", "translate(" + (dim.width/2) + " ," + (reads_dim.height + 45) + ")")
       .style("text-anchor", "middle")
       .attr("fill", "black")
       .text(contig + " Position (bp)");

    svg.selectAll("line.read_alignment").remove()

    var ra = svg.selectAll("line.read_alignment")
        .data(alignments)
        .enter();
    
    ra.append("line")
        .attr("class", "read_alignment main")
        .attr("x1", function(d) { return dim.xscale(d[1]); })
        .attr("x2", function(d) { return dim.xscale(d[2]); })
        .attr("y1", function(d) { return reads_dim.yscale(d[5]); })
        .attr("y2", function(d) { return reads_dim.yscale(d[5]); })
        .style("stroke-opacity", function(d) { return mq_opacity(d[4]) })
        .style("stroke", "blue")
        .on("mouseover", function(d) {
            contig_text_hover(d[0], d[5], d[6], "end");
            contig_text_hover(d[3], d[5], d[7], "start");
        })
        .on("mouseout", contig_text_unhover);

    ra.append("line")
        .attr("class", "read_alignment clip left")
        .attr("x1", function(d) { return dim.xscale(d[0]); })
        .attr("x2", function(d) { return dim.xscale(d[1]); })
        .attr("y1", function(d) { return reads_dim.yscale(d[5]); })
        .attr("y2", function(d) { return reads_dim.yscale(d[5]); })
        .style("stroke-opacity", function(d) { return mq_opacity(d[4]); })
        .style("stroke", function(d) { return clip_colour(d[8]); })
        .on("mouseover", function(d) {
            contig_text_hover(d[0], d[5], d[6], "end");
        })
        .on("mouseout", contig_text_unhover);

    ra.append("line")
          .attr("class", "read_alignment clip right")
          .attr("contig_id", function(d) { return d[7]})
          .attr("x1", function(d) { return dim.xscale(d[2]); })
          .attr("x2", function(d) { return dim.xscale(d[3]); })
          .attr("y1", function(d) { return reads_dim.yscale(d[5]); })
          .attr("y2", function(d) { return reads_dim.yscale(d[5]); })
          .style("stroke-opacity", function(d) { return mq_opacity(d[4]) })
          .style("stroke", function(d) { return clip_colour(d[9])})
        .on("mouseover", function(d) {
            contig_text_hover(d[3], d[5], d[7], "start");
        })
        .on("mouseout", contig_text_unhover);

}

function reorder_assembly(contigs, assembly_dim, assembly_svg) {
    assembly_dim.yscale.domain(contigs.map(d => d.name));

    t = d3.transition().duration(1000).ease(d3.easeCubic);

    assembly_svg
        .transition(t)
        .call(d3.axisLeft(assembly_dim.yscale));

    assembly_svg.selectAll("rect.ploidy")
        .transition(t)
        .attr("y", function(d) { return assembly_dim.yscale(d3.select(this).attr("contig")); });

    assembly_svg.selectAll("circle")
        .transition(t)
        .attr("cy", function(d) { return assembly_dim.yscale(d3.select(this).attr("contig")) + assembly_dim.yscale.bandwidth()/2; });

    assembly_svg.selectAll("path.contig_link")
        .transition(t)
        .attr("d", d3.linkHorizontal()
                     .x(function(d) { return d.x == -1 ? 0 : dim.xscale(d.x); })
                     .y(function(d) { return assembly_dim.yscale(d.y) + assembly_dim.yscale.bandwidth()/2; })
        );

    assembly_svg.selectAll("rect.contig_alignment.self")
        .transition(t)
        .attr("y", function(d) { return assembly_dim.yscale(d3.select(this).attr("contig1")) + assembly_dim.yscale.bandwidth(); });

    assembly_svg.selectAll("rect.contig_alignment.other")
        .transition(t)
        .attr("y", function(d) { return assembly_dim.yscale(d3.select(this).attr("contig2")) + assembly_dim.yscale.bandwidth(); });

}

function connect_alignments(d, i) {
    this_y = assembly_dim.yscale(d3.select(this).attr("contig1"))
    other_y = assembly_dim.yscale(d3.select(this).attr("contig2"))
    
    if (this_y < other_y) {
        this_y += assembly_dim.yscale.bandwidth()*2;
        other_y += assembly_dim.yscale.bandwidth();
    } else {
        this_y += assembly_dim.yscale.bandwidth();
        other_y += assembly_dim.yscale.bandwidth()*2;
    }

    poly = [{"x":dim.xscale(d[0]), "y":this_y },
            {"x":dim.xscale(d[3]), "y":other_y },
            {"x":dim.xscale(d[4]), "y":other_y },
            {"x":dim.xscale(d[1]), "y":this_y }];

    assembly_svg.selectAll("polygon")
            .data([poly])
            .enter()
            .append("polygon")
            .attr("points",function(d) { 
                   return d.map(function(d) {
                       return [d.x,d.y].join(",");
                   }).join(" ");
               })
            .attr("fill", "blue")
            .attr("fill-opacity",0.1);
}

function disconnect_alignments(d, i) {
    assembly_svg.selectAll("polygon").remove()
}



function show_contig_alignments(contig, assembly_svg) {

    assembly_svg.selectAll("path.contig_link").remove();
    assembly_svg.selectAll("rect.contig_alignment").remove();

    if (contig == current_aligned_contig) {
        current_aligned_contig = '';
        return;
    }

    current_aligned_contig = contig;
    
    assembly_svg.selectAll("path.contig_link")
        .data(contig_links[contig])
        .enter()
        .append("path")
        .attr("class", "contig_link")
        .attr("d", d3.linkHorizontal()
                    .x(function(d) { return d.x == -1 ? 0 : dim.xscale(d.x); })
                    .y(function(d) { return assembly_dim.yscale(d.y) + assembly_dim.yscale.bandwidth()/2; })
        )
        .style("stroke-opacity", function(d) {
            return 0.1 + 0.9*contig_coverage_prop[contig_short_id[contig]][contig_short_id[d.target.y]];
        })
        .style("stroke", "purple")

    assembly_svg.selectAll("rect.contig_alignment.self")
        .data(contig_alignments[contig_short_long[contig]])
        .enter()
        .append("rect")
        .attr("class", "contig_alignment self")
        .attr("contig1", contig)
        .attr("contig2", function(d) { return contig_id_short[d[2]]; })
        .attr("x", function(d) { return dim.xscale(d[0]); })
        .attr("width", function(d) { return dim.xscale(d[1])-dim.xscale(d[0]); })
        .attr("y", function(d) { return assembly_dim.yscale(contig) + assembly_dim.yscale.bandwidth(); })
        .attr("height", function(d) { return assembly_dim.yscale.bandwidth(); })
        .style("fill", "blue")
        .style("fill-opacity", 0.1)
        .style("stroke-opacity", 0)
        .on("mouseover", connect_alignments)
        .on("mouseout", disconnect_alignments);

    assembly_svg.selectAll("rect.contig_alignment.other")
        .data(contig_alignments[contig_short_long[contig]])
        .enter()
        .append("rect")
        .attr("class", "contig_alignment other")
        .attr("contig1", contig)
        .attr("contig2", function(d) { return contig_id_short[d[2]]; })
        .attr("x", function(d) { return dim.xscale(d[3]); })
        .attr("width", function(d) { return dim.xscale(d[4])-dim.xscale(d[3]); })
        .attr("y", function(d) { return assembly_dim.yscale(contig_id_short[d[2]]) + assembly_dim.yscale.bandwidth(); })
        .attr("height", function(d) { return assembly_dim.yscale.bandwidth(); })
        .style("fill", "blue")
        .style("fill-opacity", 0.1)
        .style("stroke-opacity", 0)
        .on("mouseover", connect_alignments)
        .on("mouseout", disconnect_alignments);
}

function build_contig(contig, dim, assembly_dim, windowsize) {

    contig.selectAll("rect.ploidy")
        .data(ploidys[contig.attr("longname")])
        .enter()
        .append("rect")
        .attr("class", "ploidy")
        .attr("contig", contig.attr("name"))
        .attr("y", function(d) { return assembly_dim.yscale(contig.attr("name")); })
        .attr("height", assembly_dim.yscale.bandwidth())
        .attr("x", function(d, i) { return dim.xscale(i*(windowsize/2)); }) // windowsize/2 because they are sliding
        .attr("width", function(d, i) {
            // either window size or the remainder at the end of the contig; subtract the left contig overhang up to position 0
            return dim.xscale(d3.min([windowsize, contig.attr("length") - i*(windowsize/2)])) - dim.xscale(0);
        })
        .attr("fill", function(d) { return assembly_dim.ploidyscale((1+d*0.8)/5); })
        .attr("stroke-opacity", 0);

    contig.append("circle")
        .attr("class", "telomere start")
        .attr("cx", dim.xscale(0))
        .attr("opacity", function(d) {return d.tel_start / 20; });
    
    contig.append("circle")
        .attr("class", "telomere end")
        .attr("cx", function(d) { return dim.xscale(d.length) })
        .attr("opacity", function(d) {return d.tel_end / 20; });

    contig.selectAll(".telomere")
        .attr("contig", contig.attr("name"))
        .attr("cy", function(d) { return assembly_dim.yscale(d.name) + assembly_dim.yscale.bandwidth()/2; })
        .attr("r", assembly_dim.yscale.bandwidth())
        .attr("fill", "red");
}

var max_read_depth = 0;
var min_read_pos = 0;
var max_read_pos = 0;

for (var key in read_alignments) {
    max_read_depth = check_max(max_read_depth, read_alignments[key], 5);
    min_read_pos   = check_min(min_read_pos, read_alignments[key], 0);
    max_read_pos   = check_max(max_read_pos, read_alignments[key], 3);
}

var max_cluster = d3.max(contigs.map(c => c.cluster))
var max_contig_name_length = d3.max(contigs.map(c => c.name.length))
var dim = { margin: {top: 100, right: 80, bottom: 50, left: max_contig_name_length * 10 } };

dim.width = 1000 - dim.margin.left - dim.margin.right;

// Pad X axis with 2% of the maximum length, for contig alignment curves
var leftpad = (max_read_pos-min_read_pos) * 0.02
dim.xscale = d3.scaleLinear()
               .domain([min_read_pos-leftpad, max_read_pos])
               .range([0, dim.width]);

var xaxis = d3.axisBottom(dim.xscale);


var assembly_dim = {height: contigs.length * 29};

assembly_dim.yscale = d3.scaleBand()
                      .domain(contigs.map(d => d.name))
                      .rangeRound([0, assembly_dim.height])
                      .paddingInner(0.8)
                      .paddingOuter(0.4);

assembly_dim.ploidyscale = d3.scaleSequential(d3.interpolateGreens);
assembly_dim.gcscale = d3.scaleSequential(d3.interpolateRainbow);
assembly_dim.clusterscale = d3.scaleOrdinal(d3.schemeDark2);

var assembly_svg = d3.select("#assembly_plot")
            .append("svg")
            .attr("width", dim.width + dim.margin.left + dim.margin.right/2)
            .attr("height", assembly_dim.height + dim.margin.top + dim.margin.bottom)
            .append("g")
            .attr("transform", "translate(" + dim.margin.left + "," + (dim.margin.top + assembly_dim.height) + ")")
            .call(xaxis)
            .attr("class", "xaxis")
            .append("g")
            .attr("transform", "translate(0,-" + assembly_dim.height + ")")
            .call(d3.axisLeft(assembly_dim.yscale))
            .attr("class", "yaxis");

assembly_svg
    .selectAll(".tick")
    .on("click", function(d) { show_contig_alignments(d, assembly_svg); })

assembly_svg.append("text")
    .attr("class", "xaxislabel")
    .attr("transform", "translate(" + (dim.width/2) + " ," + (assembly_dim.height + 45) + ")")
    .style("text-anchor", "middle")
    .attr("fill", "black")
    .text("Position (bp)");


var contig_groups = assembly_svg.selectAll("g.contig")
    .data(contigs, function(d) { return d.name })
    .enter()
    .append("g")
    .attr("class", "contig")
    .attr("name", function(d) { return d.name })
    .attr("longname", function(d) { return d.longname })
    .attr("length", function(d) { return d.length })
    .each(function(d) { build_contig(d3.select(this), dim, assembly_dim, windowsize); });


var reads_dim = { height: 300 };

reads_dim.yscale = d3.scaleLinear()
                     .domain([0, max_read_depth])
                     .range([reads_dim.height, 0]);

yaxis = d3.axisLeft(reads_dim.yscale)
                     
reads_svg = d3.select("#read_alignment_plot")
              .append("svg")
              .attr("width", dim.width + dim.margin.left + dim.margin.right)
              .attr("height", reads_dim.height + dim.margin.top + dim.margin.bottom)
              .append("g")
              .attr("transform", "translate(" + dim.margin.left + "," + (dim.margin.top + reads_dim.height) + ")")
              .call(xaxis)
              .attr("class", "xaxis")
              .append("g")
              .attr("transform", "translate(0,-" + reads_dim.height + ")")
              .call(yaxis)
              .attr("class", "yaxis")

reads_svg.append("text")
         .attr("class", "yaxislabel")
         .attr("transform", "rotate(-90)")
         .attr("y", 0 - (dim.margin.left * 0.6))
         .attr("x",0 - (reads_dim.height / 2))
         .attr("fill", "black")
         .style("text-anchor", "middle")
         .text("Reads"); 

reads_svg.selectAll("line.ploidy")
   .data(ploidy_depths.filter(d => d.name != "repeat"))
   .enter()
   .append("line")
   .attr("class", "ploidy")
   .attr("x1", dim.xscale.range()[0]+1) // +1 to avoid axis
   .attr("x2", dim.xscale.range()[1])
   .attr("y1", function(d) { return reads_dim.yscale(d.depth) })
   .attr("y2", function(d) { return reads_dim.yscale(d.depth) })
   .style("stroke", function(d, i) { return assembly_dim.ploidyscale((1+i*0.8)/5); })
   .style("stroke-width", 2)

reads_svg.selectAll("text.ploidy")
   .data(ploidy_depths)
   .enter()
   .append("text")
   .attr("x", dim.xscale.range()[1] + 10 )
   .attr("y", function(d) { return reads_dim.yscale(d.depth)+2 })
   .style("fill", function(d, i) { return assembly_dim.ploidyscale((1+i*0.8)/5) })
   .style("text-anchor", "start")
   .text(function(d) { return d.name })


function update_assembly(sort=false) {
    if (sort) {
        $('#contig_table').bootstrapTable('multipleSort');
    }
    reorder_assembly(contigs, assembly_dim, assembly_svg);
    $('#assembly_table').bootstrapTable("load", calculate_stats(contigs));
}

function include_checkbox(value) {
    return '<input type="checkbox" ' + (value==true ? ' checked ' : '' ) + '</input>';
}

$.fn.editable.defaults.mode = 'inline';
$('#assembly_table').bootstrapTable({data: calculate_stats(contigs)});
$('#contig_table').bootstrapTable({
    editable: true,
    showColumns: true,
    showMultiSort: true,
    reorderableRows: true,
    useRowAttrFunc: true,
    sortPriority: [{"sortName":"included","sortOrder":"desc"}, {"sortName":"length","sortOrder":"desc"}],
    showExport: true,
    exportTypes: ['csv'],
    data: contigs,
    onPostBody: function() { update_assembly() },
    onReorderRow: function(new_order) {
        new_ids = new_order.map(d=>d.id)
        contigs.sort(function(a,b) {
            return new_ids.indexOf(a.id) - new_ids.indexOf(b.id);
        })
        update_assembly();
    },
    onCheck: function(row) {
        plot_read_alignments(read_alignments[row.longname], dim, assembly_dim, reads_dim, reads_svg, contig_names[row.longname]);
    },
    onClickCell: function(field, value, row, $element) {
        if (field === 'included') {
            row.included = value == 1 ? 0 : 1;
            update_assembly(sort=true);
        }
    }
});

update_assembly(sort=true);
$('#contig_table').bootstrapTable('check', 0);
</script>
</body>
</html>